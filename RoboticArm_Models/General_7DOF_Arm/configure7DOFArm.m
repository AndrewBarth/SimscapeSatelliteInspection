function arm = configure7DOFArm(arm,q,sat)
    % arm = arm_in;
    dtr = pi/180;

    % Set DH parameters
    thetaOffset = [0 0 0 0 0 0 -90]*dtr;

    DHparams(1,:) = [0 0 0 0];
    DHparams(2,:) = [ arm.Link_Length(1) 0.0              90.0*dtr q(1)+thetaOffset(1)];
    DHparams(3,:) = [ arm.Link_Length(2) 0.0             -90.0*dtr q(2)+thetaOffset(2)];
    DHparams(4,:) = [ arm.Link_Length(3) 0.0              90.0*dtr q(3)+thetaOffset(3)];
    DHparams(5,:) = [-arm.Link_Length(4) 0.0             -90.0*dtr q(4)+thetaOffset(4)];
    DHparams(6,:) = [ arm.Link_Length(5) 0.0              90.0*dtr q(5)+thetaOffset(5)];
    DHparams(7,:) = [-arm.Link_Length(6) 0.0             -90.0*dtr q(6)+thetaOffset(6)];
    DHparams(8,:) = [ arm.Link_Length(7) 0.0               0.0*dtr q(7)+thetaOffset(7)];


    % Set up mass properties
    % THESE ARE PROBABLY INCORRECT. NEED TO MATCH THIS WITH ARM MODEL
    m_base = sat.service.mass + arm.smiData.Solid(1).mass;  % Sum satellite base and arm base

    % Map the link indices to those auto-generated by Simscape
    baseIdx = [11 9];
    linkIdx{1} = [7 8];
    linkIdx{2} = [10];
    linkIdx{3} = [1 4];
    linkIdx{4} = [2];
    linkIdx{5} = [3 5];
    linkIdx{6} = [6];
    linkIdx{7} = [12];

    inertiaRot(11,:,:) = XRot(-pi/2);
    inertiaRot(9,:,:)  = XRot(-pi/2);
%     inertiaRot(7,:,:)  = XRot(-pi/2);
    inertiaRot(7,:,:)  = XRot(0);
    inertiaRot(8,:,:)  = XRot(0);
    inertiaRot(10,:,:) = XRot(-pi/2);
%     inertiaRot(1,:,:)  = XRot(-pi/2);
    inertiaRot(1,:,:)  = XRot(0);
    inertiaRot(4,:,:)  = XRot(0);
    inertiaRot(2,:,:)  = XRot(-pi/2);
%     inertiaRot(3,:,:)  = XRot(-pi/2);
    inertiaRot(3,:,:)  = XRot(0);
    inertiaRot(5,:,:)  = XRot(0);
    inertiaRot(6,:,:)  = XRot(-pi/2);
    inertiaRot(12,:,:) = XRot(-pi/2);

    m_base = sat.service.mass;
    for j=1:length(baseIdx)
        m_base = m_base + arm.smiData.Solid(baseIdx(j)).mass;
    end
    for i = 1:arm.nLink
        m_link(i) = 0;
        for j=1:length(linkIdx{i})
            m_link(i) = m_link(i) + arm.smiData.Solid(linkIdx{i}(j)).mass;
        end
    end

    mt = m_base + sum(m_link);
    massVec = [m_base m_link];
    
    % NEED TO ADD IN INERTIA OF ARM BASE (also check order of PoI variables)
    inertiaMatBase = [sat.service.MoI(1) sat.service.PoI(1) sat.service.PoI(2); ... 
                      sat.service.PoI(1) sat.service.MoI(2) sat.service.PoI(3); ...
                      sat.service.PoI(2) sat.service.PoI(3) sat.service.MoI(3)];

    for i = 1:arm.nLink
        if i~=1 && i~=3 && i~=5
            modelInertia(i,:,:) = zeros(3,3);
            modelInertia(i,:,:) = [arm.smiData.Solid(linkIdx{i}).MoI(1) arm.smiData.Solid(linkIdx{i}).PoI(1) arm.smiData.Solid(linkIdx{i}).PoI(2); ... 
                                   arm.smiData.Solid(linkIdx{i}).PoI(1) arm.smiData.Solid(linkIdx{i}).MoI(2) arm.smiData.Solid(linkIdx{i}).PoI(3); ...
                                   arm.smiData.Solid(linkIdx{i}).PoI(2) arm.smiData.Solid(linkIdx{i}).PoI(3) arm.smiData.Solid(linkIdx{i}).MoI(3)];
        end
    end

    modelInertia(1,:,:) = [0.1398 0 -0.0228; 0 0.2035 0.0; -0.0228 0.0 0.1569];
    modelInertia(3,:,:) = [5.4823 0.0 -0.0281; 0.0 5.4867 0.0; -0.0281 0.0 0.0441];
    modelInertia(5,:,:) = [4.4390 0.0 -0.0260; 0.0 4.4434 0.0; -0.0260 0.0 0.0441];
    for i = 1:arm.nLink
        inertiaMat(i,:,:) = zeros(3,3);
        for j=1:length(linkIdx{i})
            linkI = linkIdx{i}(j);
            % THIS CALC IS NOT ACCURATE. CANNOT JUST ADD INERTIAS LIKE
            % THIS. NEED TO USE PARALLEL AXIS THEOREM
%             inertiaMat(i,:,:) = squeeze(inertiaMat(i,:,:)) + squeeze(inertiaRot(linkI,:,:))'* ...
%                                                          [smiData.Solid(linkI).MoI(1) smiData.Solid(linkI).PoI(1) smiData.Solid(linkI).PoI(2); ... 
%                                                           smiData.Solid(linkI).PoI(1) smiData.Solid(linkI).MoI(2) smiData.Solid(linkI).PoI(3); ...
%                                                           smiData.Solid(linkI).PoI(2) smiData.Solid(linkI).PoI(3) smiData.Solid(linkI).MoI(3)]*squeeze(inertiaRot(linkI,:,:));
            inertiaMat(i,:,:) = squeeze(inertiaRot(linkI,:,:))'*squeeze(modelInertia(i,:,:))*squeeze(inertiaRot(linkI,:,:));
        end
    end
    linkInertia = zeros(arm.nLink,3,3);
    arm.massProperties.mt = mt;
    arm.massProperties.massVec = massVec;
    arm.massProperties.inertiaMatBase = inertiaMatBase;
    arm.massProperties.inertiaMat = inertiaMat;
    arm.massProperties.linkInertia = linkInertia;
    arm.thetaOffset = thetaOffset;
    arm.DHparams = DHparams;
    arm.thetaOffset = thetaOffset;


